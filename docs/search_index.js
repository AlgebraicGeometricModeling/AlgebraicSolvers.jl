var documenterSearchIndex = {"docs":
[{"location":"code/3_functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"code/3_functions/","page":"Functions","title":"Functions","text":"AlgebraicSolvers.rel_error","category":"page"},{"location":"code/3_functions/#AlgebraicSolvers.rel_error","page":"Functions","title":"AlgebraicSolvers.rel_error","text":"Vector of relative errors of P at the points X\n\n\n\n\n\n","category":"function"},{"location":"code/3_functions/","page":"Functions","title":"Functions","text":"AlgebraicSolvers.alpha_beta","category":"page"},{"location":"code/3_functions/#AlgebraicSolvers.alpha_beta","page":"Functions","title":"AlgebraicSolvers.alpha_beta","text":"alpha, beta quantities for Newton convergence to an approximate zero.\n\nIf alpha < 0.125, then the approximate zero is withing 2*beta from Xi and Newton methods converges to it from Xi quadratically.\nIf alpha < 0.02, then Newton method converges from all points in the ball of center Xi and radius 2*beta.\n\n\n\n\n\n","category":"function"},{"location":"code/2_resultants/#Resultants","page":"Resultants","title":"Resultants","text":"","category":"section"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"Greedy implementation of the Canny-Emiris formula as it was presented in \"A Greedy Approach to the Canny-Emiris Formula\" with the introduction of type functions. The underlying system of equations is written as:","category":"page"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"F_i = sum_a in mathcalA_iu_iachi^a quad i = 0dotsn","category":"page"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"for some finite sets of supports mathcalA_i subset M in a lattice of rank n. This implementation treats the cases in which the Newton polytopes  Delta_i = conv(mathcalA_i) are zonotopes (sums of line segments) or products of simplices (which correspond to multihomogeneous systems of equations).","category":"page"},{"location":"code/2_resultants/#Zonotopes","page":"Resultants","title":"Zonotopes","text":"","category":"section"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"Let v_1dotsv_n in M be independent vectors generating an n-zonotope. The supports of our zonotopes are: ","category":"page"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"mathcalA_i^ = big sum_j = 1^n lambda_j v_j in mathbbZ^n mid quad lambda_j in mathbbZ quad 0  leq lambda_j leq a_ijbig","category":"page"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"for some a_ij quad i = 0dotsn quad j = 1dotss. Let V be the n times n matrix whose columns are v_1dotsv_n and let A be the matrix whose entries are the a_ij.","category":"page"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"The function CannyEmiris.Zonotopes receives these two matrices and returns two symbolic matrices mathcalH_mathcalGmathcalE_mathcalG which correspond to the rational formula for the sparse resultant:","category":"page"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"Res_mathcalA = big(fracdet(mathcalH_mathcalG)det(mathcalE_mathcalG)big)^det(V)","category":"page"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"which follows from Theorem 1.1 and Corollary 3.1 on the text. ","category":"page"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"Moreover, the program prints the polynomials chi^b-a(b)F_i(b) corresponding to all the lattice points in the greedy subset b in mathcalG, the size of the matrix and the degree of the resultant (which corresponds to the lattice points in mixed cells).","category":"page"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"Let's see an example of the use of this function which corresponds to the system of Example 1.1 in the text.","category":"page"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"\njulia> Using AlgebraicSolvers\n\njulia> A = [[1,1] [1,1] [1,1]]\n2×3 Matrix{Int64}:\n 1  1  1\n 1  1  1\n\njulia> H = [[1,0] [0,1]]\n2×2 Matrix{Int64}:\n 1  0\n 0  1\n\njulia> CE, PM = CannyEmiris.Zonotopes(A,H)\nThe rows of the Canny-Emiris matrix x^{b-a(b)}F_{i(b)} are: \n[0, 1]-> x^[0, 1]*F_2\n[0, 2]-> x^[0, 1]*F_1\n[1, 0]-> x^[1, 0]*F_2\n[1, 1]-> x^[1, 1]*F_2\n[1, 2]-> x^[0, 1]*F_0\n[2, 0]-> x^[1, 0]*F_1\n[2, 1]-> x^[1, 0]*F_0\n[2, 2]-> x^[1, 1]*F_1\n\nThe size of the greedy Canny-Emiris matrix is: 8\nThe degree of the resultant is: 6\n\nThe sparse resultant is the ratio of the determinants of the returned matrices to the power 1.0\n\n\njulia> CE\n8×8 Matrix{SymPy.Sym}:\n (u_{2, [0, 0]})  (u_{2, [0, 1]})                0  (u_{2, [1, 0]})  (u_{2, [1, 1]})                0                0                0\n (u_{1, [0, 0]})  (u_{1, [0, 1]})                0  (u_{1, [1, 0]})  (u_{1, [1, 1]})                0                0                0\n               0                0  (u_{2, [0, 0]})  (u_{2, [0, 1]})                0  (u_{2, [1, 0]})  (u_{2, [1, 1]})                0\n               0                0                0  (u_{2, [0, 0]})  (u_{2, [0, 1]})                0  (u_{2, [1, 0]})  (u_{2, [1, 1]})\n (u_{0, [0, 0]})  (u_{0, [0, 1]})                0  (u_{0, [1, 0]})  (u_{0, [1, 1]})                0                0                0\n               0                0  (u_{1, [0, 0]})  (u_{1, [0, 1]})                0  (u_{1, [1, 0]})  (u_{1, [1, 1]})                0\n               0                0  (u_{0, [0, 0]})  (u_{0, [0, 1]})                0  (u_{0, [1, 0]})  (u_{0, [1, 1]})                0\n               0                0                0  (u_{1, [0, 0]})  (u_{1, [0, 1]})                0  (u_{1, [1, 0]})  (u_{1, [1, 1]})\n\njulia> PM\n2×2 Matrix{SymPy.Sym}:\n (u_{2, [0, 0]})  (u_{2, [1, 1]})\n (u_{1, [0, 0]})  (u_{1, [1, 1]})","category":"page"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"The program will return an error if i) the matrix A or H do not have the desired dimensions, ","category":"page"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"julia> A = [[1,1] [1,1]]\n2×2 Matrix{Int64}:\n 1  1\n 1  1\n\njulia> H\n2×2 Matrix{Int64}:\n 1  0\n 0  1\n\njulia> CE, PM = CannyEmiris.Zonotopes(A,H)\nThe matrix of the a_{i,j} does not have the correct dimensions\n(Dict{Any, Any}(), Dict{Any, Any}())","category":"page"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"ii) if H does not correspond to an n-zonotope","category":"page"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"julia> H = [[1,0] [0,0]]\n2×2 Matrix{Int64}:\n 1  0\n 0  0\n\njulia> CE, PM = CannyEmiris.Zonotopes(A,H)\nThe vectors do not correspond to an n-zonotope.\n(Dict{Any, Any}(), Dict{Any, Any}())","category":"page"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"or iii) entries of A are not ordered in the sense  0  a_0j leq a_1j leq dots leq a_n-1j quad j = 1dotsn:","category":"page"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"julia> A = [[2,1] [1,1] [1,1]]\n2×3 Matrix{Int64}:\n 2  1  1\n 1  1  1\n\njulia> H = [[1,0] [0,1]]\n2×2 Matrix{Int64}:\n 1  0\n 0  1\n\njulia> CE, PM = CannyEmiris.Zonotopes(A,H)\nThe matrix of the a_{i,j} does not satisfy a_{i-1,j} <= a_{i,j}\n(Dict{Any, Any}(), Dict{Any, Any}())","category":"page"},{"location":"code/2_resultants/#Multihomogeneous-systems","page":"Resultants","title":"Multihomogeneous systems","text":"","category":"section"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"Let now N represent the vector of n1,...ns in a multihomogeneous system in mathbbP^n_1 times dots times mathbbP^n_s and let D be a matrix whose columns are the multidegrees of the polynomials of the system so that:","category":"page"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"mathcalA_i = big(b_jl)_l = 1dotss^j = 1dotsn_l in oplus_l=1^smathbbZ^n_l  b_jl geq 0 quad sum_j=0^n_lb_jl leq d_il  quad i = 0dotsn","category":"page"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"The function CannyEmiris.Multihomogeneous(D::Matrix,N::Vector) receives these two matrices D and N and returns and returns two symbolic matrices which are the Canny-Emiris matrix and its principal minor, as before. Let's show its use in the system corresponding to Example 4.1.","category":"page"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"julia> N = [2]\n1-element Vector{Int64}:\n 2\n\njulia> D = [2 2 1]\n1×3 Matrix{Int64}:\n 2  2  1\n\njulia> CE,PM = CannyEmiris.Multihomogeneous(D,N)\nThe rows of the Canny-Emiris matrix x^{b-a(b)}F_{i(b)} are: \n[2, 1]-> x^[2, 1]*F_2\n[3, 1]-> x^[3, 1]*F_2\n[1, 2]-> x^[1, 2]*F_2\n[2, 2]-> x^[2, 2]*F_2\n[1, 3]-> x^[1, 3]*F_2\n[4, 1]-> x^[2, 1]*F_1\n[3, 2]-> x^[1, 2]*F_1\n[2, 3]-> x^[2, 1]*F_0\n[1, 4]-> x^[1, 2]*F_0\n\nThe size of the greedy Canny-Emiris matrix is: 9\nThe degree of the resultant is: 8\n\n(SymPy.Sym[(u_{2, [0, 0]}) (u_{2, [1, 0]}) … 0 0; 0 (u_{2, [0, 0]}) … 0 0; … ; (u_{0, [0, 0]}) (u_{0, [1, 0]}) … (u_{0, [0, 2]}) 0; 0 0 … (u_{0, [1, 1]}) (u_{0, [0, 2]})], SymPy.Sym[(u_{2, \n[0, 0]});;])\n\njulia> CE\n9×9 Matrix{SymPy.Sym}:\n (u_{2, [0, 0]})  (u_{2, [1, 0]})                0  (u_{2, [0, 1]})                0                0                0                0                0\n               0  (u_{2, [0, 0]})                0                0                0  (u_{2, [1, 0]})  (u_{2, [0, 1]})                0                0\n               0                0  (u_{2, [0, 0]})  (u_{2, [1, 0]})  (u_{2, [0, 1]})                0                0                0                0\n               0                0                0  (u_{2, [0, 0]})                0                0  (u_{2, [1, 0]})  (u_{2, [0, 1]})                0\n               0                0                0                0  (u_{2, [0, 0]})                0                0  (u_{2, [1, 0]})  (u_{2, [0, 1]})\n (u_{1, [0, 0]})  (u_{1, [1, 0]})                0  (u_{1, [0, 1]})                0  (u_{1, [2, 0]})  (u_{1, [1, 1]})  (u_{1, [0, 2]})                0\n               0                0  (u_{1, [0, 0]})  (u_{1, [1, 0]})  (u_{1, [0, 1]})                0  (u_{1, [2, 0]})  (u_{1, [1, 1]})  (u_{1, [0, 2]})\n (u_{0, [0, 0]})  (u_{0, [1, 0]})                0  (u_{0, [0, 1]})                0  (u_{0, [2, 0]})  (u_{0, [1, 1]})  (u_{0, [0, 2]})                0\n               0                0  (u_{0, [0, 0]})  (u_{0, [1, 0]})  (u_{0, [0, 1]})                0  (u_{0, [2, 0]})  (u_{0, [1, 1]})  (u_{0, [0, 2]})\n\njulia> PM\n1×1 Matrix{SymPy.Sym}:\n (u_{2, [0, 0]})","category":"page"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"Again, this function will return nothing if the dimension conditions and the order. ","category":"page"},{"location":"code/2_resultants/#Other-functions-to-call","page":"Resultants","title":"Other functions to call","text":"","category":"section"},{"location":"code/2_resultants/#MultihomogeneousEmbedding","page":"Resultants","title":"MultihomogeneousEmbedding","text":"","category":"section"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"The function CannyEmiris.MultihomogeneousEmbedding(MULTI_A::Matrix{Int64}, MULTI_N::Vector{Int64}))  builds the embedding of the multihomogeneous system into a zonotope system. This system is given by the supports:","category":"page"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":" overlinemathcalA_i = big(b_jl)_l = 1dotss^j=1dotsn_l in oplus_j=1^smathbbZ^n_j    0 leq sum_j = J^n_lb_jl leq d_ijquad l = 1dotss quad J = 1dotsn_l","category":"page"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"\njulia> N = [2]\n1-element Vector{Int64}:\n 2\n\njulia> D = [2 2 1]\n1×3 Matrix{Int64}:\n 2  2  1\n\njulia> CannyEmiris.MultihomogeneousEmbedding(D,N)\n([2 2 1; 2 2 1], [1 -1; 0 1])\n ","category":"page"},{"location":"code/2_resultants/#GenerateTypeFunctions","page":"Resultants","title":"GenerateTypeFunctions","text":"","category":"section"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"The function CannyEmiris.GenerateTypeFunctions(n::Int) constructs the iterator that produces all the type functions varphi1dotsn xrightarrow 0dotsn satisfying the condition on the greedy subset mathcalG:","category":"page"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"sum_i = 0^I-1 t_bi leq I quad forall I = 1dotsn where t_bi = varphi^-1(i)","category":"page"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"julia> p = CannyEmiris.GenerateTypeFunctions(2)\nMain.CannyEmiris.TypeFunctions{Vector{Int64}}([0, 1, 2], 2)\n\njulia> for x in p println(x) end\n[0, 1]\n[0, 2]\n[1, 0]\n[1, 1]\n[1, 2]\n[2, 0]\n[2, 1]\n[2, 2]\n ","category":"page"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"AlgebraicSolvers.CannyEmiris","category":"page"},{"location":"code/2_resultants/#AlgebraicSolvers.CannyEmiris","page":"Resultants","title":"AlgebraicSolvers.CannyEmiris","text":"Module which provides optimised resultant constructions for multi-homogeneous systems.\n\n\n\n\n\n","category":"module"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"AlgebraicSolvers.CannyEmiris.Multihomogeneous","category":"page"},{"location":"code/2_resultants/#AlgebraicSolvers.CannyEmiris.Multihomogeneous","page":"Resultants","title":"AlgebraicSolvers.CannyEmiris.Multihomogeneous","text":"Add some documentation: what are A, H, Coeff, ...\n\n\n\n\n\n","category":"function"},{"location":"code/2_resultants/","page":"Resultants","title":"Resultants","text":"AlgebraicSolvers.CannyEmiris.Zonotopes ","category":"page"},{"location":"code/2_resultants/#AlgebraicSolvers.CannyEmiris.Zonotopes","page":"Resultants","title":"AlgebraicSolvers.CannyEmiris.Zonotopes","text":"Add some documentation: what are A, H, Coeff, ...\n\n\n\n\n\n","category":"function"},{"location":"code/1_solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"code/1_solvers/#Matrices","page":"Solvers","title":"Matrices","text":"","category":"section"},{"location":"code/1_solvers/","page":"Solvers","title":"Solvers","text":"AlgebraicSolvers.matrix_macaulay","category":"page"},{"location":"code/1_solvers/#AlgebraicSolvers.matrix_macaulay","page":"Solvers","title":"AlgebraicSolvers.matrix_macaulay","text":"matrix_macaulay(P, L, X, ish = false)\n\nP polynomial system\nL array of monomials\nX array of variables\nish (optional) set to true if the polynomials are homogeneous\n\nSylvester matrix of all monomial multiples mi*pi in degree ≤ d, where d=max(deg(p1),...,deg(pn)).\n\n\n\n\n\n","category":"function"},{"location":"code/1_solvers/","page":"Solvers","title":"Solvers","text":"AlgebraicSolvers.matrix_toric","category":"page"},{"location":"code/1_solvers/#AlgebraicSolvers.matrix_toric","page":"Solvers","title":"AlgebraicSolvers.matrix_toric","text":"R, L = matrix_toric(P)\n\nP polynomial system\n\nIt outputs \n\nR the Sylvester matrix of all monomial multiples mi*pi for mi in supp(∏_{j != i} pj).\nL the list of monomials indexing the rows of R\n\n\n\n\n\n","category":"function"},{"location":"code/1_solvers/#Solutions","page":"Solvers","title":"Solutions","text":"","category":"section"},{"location":"code/1_solvers/","page":"Solvers","title":"Solvers","text":"AlgebraicSolvers.solve_macaulay","category":"page"},{"location":"code/1_solvers/#AlgebraicSolvers.solve_macaulay","page":"Solvers","title":"AlgebraicSolvers.solve_macaulay","text":"solve_macaulay(P, X, rho)\n\nP polynomial system\nX array of variables\nrho degree of regularity for the Sylvester matrix construction (optional)\n\nSolve the system P=[p1, ..., pn], building Sylvester matrix of all monomial multiples mi*pi in degree ≤ ρ.\n\nThe default value for ρ is ∑ deg(pi) - n + 1.\n\nExample\n\njulia> using AlgebraicSolvers, DynamicPolynomials\n\njulia> X = @polyvar x y\n(x, y)\n\njulia> P = [2-x*y,x+y-2]\n2-element Vector{Polynomial{true, Int64}}:\n -xy + 2\n x + y - 2\n\njulia> solve_macaulay(P,X)\n-- Degrees [2, 1]\n-- Homogeneity false\n-- Monomials 6 degree 2   0.0(s)\n-- Macaulay matrix 4x6   6.4849853515625e-5(s)\n-- Null space 6x2   5.1021575927734375e-5(s)\n-- Qr basis 2   4.601478576660156e-5(s)\n-- Mult matrices 1.6927719116210938e-5(s)\n-- Eigen diag   9.799003601074219e-5(s)\n\n2×2 Matrix{ComplexF64}:\n 1.0+1.0im  1.0-1.0im\n 1.0-1.0im  1.0+1.0im\n\n\n\n\n\n\n","category":"function"},{"location":"code/1_solvers/","page":"Solvers","title":"Solvers","text":"AlgebraicSolvers.solve_toric","category":"page"},{"location":"code/1_solvers/#AlgebraicSolvers.solve_toric","page":"Solvers","title":"AlgebraicSolvers.solve_toric","text":"solve_toric(P, X)\n\nP polynomial system\nX array of variables\n\nSolve the system P=[p1, ..., pn], building Sylvester matrix of all monomial multiples mi*pi for mi in supp(∏_{j != i} pj).\n\n\n\n\n\n","category":"function"},{"location":"#AlgebraicSolvers","page":"Home","title":"AlgebraicSolvers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Package for the solution of polynomial systems and resultants","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = map(file -> joinpath(\"code\", file), filter(x ->endswith(x, \"md\"), readdir(\"code\"))) ","category":"page"}]
}
